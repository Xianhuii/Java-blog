本文介绍`Stream`的创建方式，给出业务场景示例，简单讲解源码。

# 1 `StreamSupport`

`StreamSupport`是JDK提供的用于创建和操作流的低级实用方法，这些方法通常是提供给JDK内部组件使用的。

它提供了针对`int`、`long`、`double`和引用类型元素的不同创建方法，

- `stream(Spliterator<T> spliterator, boolean parallel):Stream<T>`
- `stream(Supplier<? extends Spliterator<T>> supplier, int characteristics, boolean parallel):Stream<T>`
- `intStream(Spliterator.OfInt spliterator, boolean parallel):IntStream`
- `intStream(Supplier<? extends Spliterator.OfInt> supplier, int characteristics, boolean parallel):IntStream`
- `longStream(Spliterator.OfLong spliterator, boolean parallel):LongStream`
- `longStream(Supplier<? extends Spliterator.OfLong> supplier, int characteristics, boolean parallel):LongStream`
- `doubleStream(Spliterator.OfDouble spliterator, boolean parallel):DoubleStream`
- `doubleStream(Supplier<? extends Spliterator.OfDouble> supplier, int characteristics, boolean parallel):DoubleStream`

本质上，这些方法内部都只是调用了对应`XxxPipeline.Head`的构造函数而已。例如：

```java
public static <T> Stream<T> stream(Spliterator<T> spliterator, boolean parallel) {
    Objects.requireNonNull(spliterator);
    return new ReferencePipeline.Head<>(spliterator,
                                        StreamOpFlag.fromCharacteristics(spliterator),
                                        parallel);
```

它们对流的底层数据结构进行了封装，让我们不必关系过多的细节，不用过多花费时间去了解什么是`ReferencePipeline`，什么是`IntPipeline`。

## 1.1 案例1

由于`Arrays.stream()`返回的是顺序流，除了可以调用`stream.parallel()`方法，我们还可以使用`StreamSupport`提供的方法直接创建并行流。

```java
String[] strings = new String[]{"1","2","3","4"};
Spliterator<String> stringSpliterator = Arrays.spliterator(strings);
Stream<String> parallelStringStream = StreamSupport.stream(stringSpliterator, true);
```

## 1.2 案例2

或者，我们定义了自己的数据结构`Trie`，这时我们希望可以使用流库来处理`Trie`中的元素，需要添加以下两个模块：

1. 实现`Spliterator`接口，自定义分隔器。

2. 提供一个便捷的`stream()`方法。

   ```java
   public class Trie<E> {
       // 1、自定义Trie的元素分隔器
       static final class TrieSpliterator<E> implements Spliterator<E> {
           // 重写其中方法，制定元素遍历规则
       }
   
       // 2、提供stream()方法
       public Stream<E> stream() {
           return StreamSupport.stream(new TrieSpliterator<E>(), false);
       }
   }
   ```

# 2 `Arrays`

`Arrays`提供了一系列根据数组构造流的方法，总的来说可以分成两类。

将数组中所有元素作为数据源：

- `stream(T[] array):Stream<T>`
- `stream(int[] array):IntStream`
- `stream(long[] array):LongStream`
- `stream(double[] array):DoubleStream`

例如：

```java
String[] strings = new String[]{"1","2","3","4"};
Stream<String> stringStream = Arrays.stream(strings);
int[] ints = new int[]{1,2,3,4};
IntStream intStream = Arrays.stream(ints);
long[] longs = new long[]{1L,2L,3L,4L};
LongStream longStream = Arrays.stream(longs);
double[] doubles = new double[]{1D,2D,3D,4D};
DoubleStream doubleStream = Arrays.stream(doubles);
```

将数组中指定范围（`[startInclusive,endExclusive)`）的元素作为数据源：

- `stream(T[] array, int startInclusive, int endExclusive):Stream<T>`
- `stream(int[] array, int startInclusive, int endExclusive):IntStream`
- `stream(long[] array, int startInclusive, int endExclusive):LongStream`
- `stream(double[] array, int startInclusive, int endExclusive):DoubleStream`

例如：

```java
String[] strings = new String[]{"1","2","3","4"};
// {"1","2","3","4"}
Stream<String> stringStream = Arrays.stream(strings,0,4);
int[] ints = new int[]{1,2,3,4};
// {1,2,3}
IntStream intStream = Arrays.stream(ints,0,3);
long[] longs = new long[]{1L,2L,3L,4L};
// {2L,3L}
LongStream longStream = Arrays.stream(longs,1,3);
double[] doubles = new double[]{1D,2D,3D,4D};
// {2D}
DoubleStream doubleStream = Arrays.stream(doubles,1,2);
```

`Arrays.stream()`内部都是对`StreamSupport.xxxStream()`方法的封装，只是它们会根据形参类型提供对应的`Spliterator`实现类，对数据源进行封装。

例如，`java.util.Arrays#stream(T[], int, int)`：

```java
public static <T> Stream<T> stream(T[] array, int startInclusive, int endExclusive) {
    return StreamSupport.stream(spliterator(array, startInclusive, endExclusive), false);
}
```

此外，还需要注意的是，这些方法返回的都是顺序流。但是我们可以通过手动调用`parallel()`方法将其转成并行流。例如：

```java
Stream<String> parallelStringStream = stringStream.parallel();
```

# 3 `Collection`

# 4 `XxxStream`

# 5 `XxxStream.Builder`

